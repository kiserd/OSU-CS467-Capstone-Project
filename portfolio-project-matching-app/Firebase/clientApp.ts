// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
// TODO: Add SDKs for Firebase products that you want to use
import {
  addDoc,
  collection,
  deleteDoc,
  doc,
  getDoc,
  getDocs,
  getFirestore,
  query,
  setDoc,
  updateDoc,
  where,
} from 'firebase/firestore';
// import { getAnalytics } from "firebase/analytics";
// https://firebase.google.com/docs/web/setup#available-libraries

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

const firebaseApp = initializeApp(firebaseConfig);
const db = getFirestore();
// const analytics = getAnalytics(firebaseApp);

/*
  CREATE
*/

const addNewDoc = async (coll, payload) => {
  /*
    DESCRIPTION:  adds a new document with provided payload to the specified
                  collection. This function does not perform any input
                  validation - that is currently left to the calling function.
                  Note, document ID is generated by Firebase

    INPUT:        string indicating desired collection name and payload to be
                  added. E.g.,

                  addNewDoc('technologies', {name: _, language: _, ...})

    RETURN:       reference to new document
  */
  const collRef = collection(db, coll);
  const docRef = await addDoc(collRef, payload);
  return docRef;
}

const addNewDocWithId = async (coll, id, payload) => {
  /*
    DESCRIPTION:  adds a new document with provided payload to the specified
                  collection. This function does not perform any input
                  validation - that is currently left to the calling function.
                  Note, new document id must be provided by calling function

    INPUT:        string indicating desired collection name, id of new
                  document, and payload to be added.

    RETURN:       snapshot of new document
  */
  const docRef = doc(db, coll, id);
  await setDoc(docRef, payload);
  return await getDoc(docRef);
}

/*
  READ
*/

const getCollectionReference = async (coll) => {
  /*
    DESCRIPTION:  gets reference to provided collection

    INPUT:        string indicating desired collection name. E.g.,
                  getCollectionReference('technologies')

    RETURN:       reference to specified collection
  */
  return collection(db, coll);
}

const getCollectionSnapshot = async (coll) => {
  /*
    DESCRIPTION:  gets snapshot of documents from provided collection name

    INPUT:        string indicating desired collection name. E.g.,
                  getAllDocuments('technologies')

    RETURN:       snapshot of documents from specified collection
  */
  const collRef = collection(db, coll);
  const collSnap = await getDocs(collRef);
  return collSnap;
}

const getCollectionSnapshotByCriteria = async (coll, field, operator, condition) => {
  /*
  DESCRIPTION:  gets snapshot of documents from provided collection name based
                on criteria passed

  INPUT:        coll: string indicating name of collection
                field: field being compared to criteria
                operator: operator used to compare against condition e.g., '=='
                condition: value given field is being compared against
                Example: getColl...Criteria('projects', 'open', '==', true)

  RETURN:       snapshot of documents from specified collection
  */
  const collectionRef = collection(db, coll);
  const q = query(collectionRef, where(field, operator, condition));
  const querySnapshot = await getDocs(q);
  return querySnapshot
}

const getDocReferenceById = async(coll, docId) => {
  /*
  DESCRIPTION:  gets document reference from provided collection name with
                provided document ID

  INPUT:        string indicating desired collection name and string indicating
                desired document ID

  RETURN:       reference of document with provided document ID
  */
  const docRef = doc(db, coll, docId);
  return docRef;
}

const getDocSnapshotById = async(coll, docId) => {
  /*
  DESCRIPTION:  gets snapshot of document from provided collection name with
                provided document ID

  INPUT:        string indicating desired collection name and string indicating
                desired document ID

  RETURN:       snapshot of document with provided document ID
  */
  const docRef = doc(db, coll, docId);
  const querySnapshot = await getDoc(docRef);
  return querySnapshot;
}

/*
  UPDATE
*/

const updateDocument = async (coll, id, payload) => {
  /*
    DESCRIPTION:  updates an existing document with provided payload.

    INPUT:        string indicating desired collection name, id of new
                  document, and payload to be updated

    RETURN:       reference to new document
  */
  const docRef = doc(db, coll, id);
  await updateDoc(docRef, payload);
  const docSnapshot = await getDoc(docRef);
  return docSnapshot;
}

/*
  DELETE
*/

const deleteDocById = async (coll, id) => {
  /*
    DESCRIPTION:  deletes document with specified id from specified collection

    INPUT:        string indicating desired collection name and id of document
                  to be deleted

    RETURN:       todo
  */
  const docRef = doc(db, coll, id);
  await deleteDoc(docRef);
  return docRef;
}

// Firestore Project object data converter
// SOURCE: https://firebase.google.com/docs/firestore/manage-data/add-data
// looks like this would need to be implemented at the clientApp.ts level
// not sure how to get this to work for a full collection, only a single doc
// const projectConverter = {
//     toFirestore: (project) => {
//         return {
//             id: project.name,
//             name: project.name,
//             description: city.country,
//             capacity: project.capacity,
//             census: project.census,
//             open: project.open,
//             likes: project.likes,
//             owner: project.ownerId
//             };
//     },
//     fromFirestore: (snapshot, options) => {
//         // const data = snapshot.data(options);
//         return new Project(
//             snapshot.id,
//             snapshot.data().name,
//             docSnapshot.data().description,
//             docSnapshot.data().capacity,
//             docSnapshot.data().census,
//             docSnapshot.data().open,
//             docSnapshot.data().likes,
//             docSnapshot.data().ownerId
//         );
//     }
// };

// export
export {
  addNewDoc,
  addNewDocWithId,
  db,
  deleteDocById,
  firebaseApp,
  getCollectionReference,
  getCollectionSnapshot,
  getCollectionSnapshotByCriteria,
  getDocReferenceById,
  getDocSnapshotById,
  updateDocument,
};
